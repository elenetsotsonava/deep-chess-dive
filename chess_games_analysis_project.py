# -*- coding: utf-8 -*-
"""Chess_Games_Analysis_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CtNb7kBlaZWFYKjPBvmQNQvseVXBCv7E

# â™Ÿï¸ Chess Games Analysis using Python
The project uses the **Chess Games Dataset** from [Kaggle](https://www.kaggle.com/datasets/datasnaek/chess)

## ðŸ“š Step 1: Importing Libraries
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""## ðŸ“ Step 2: Loading the Dataset"""

import kagglehub

path = kagglehub.dataset_download("datasnaek/chess")

print("Path to dataset files:", path)

df = pd.read_csv("/root/.cache/kagglehub/datasets/datasnaek/chess/versions/1/games.csv")
df.head() # Show top rows

"""## ðŸ”Ž Step 3: Dataset Overview"""

print(df.info()) # Check basic info
print(df.describe())
print(df.columns)

"""## âœ¨ Step 4: Basic Data Exploration: Determining the goal and removing   unnecessary columns

Project Goals:


1.   Analyze the most successful openings

1.   Visualize player performance based on rating and color
2.   Build a basic dashboard-style report with charts

Therefore, the columns we don't need are:
*  id - Just an internal identifier, no analysis value
* increment_code - Specific to time control, not used here
*  opening_eco - Redundant if opening_name is more informative
*  created_at, last_move_at - Timestamp info we won't analyze here
*   moves - Detailed text of moves â€” good for deeper analysis but not now
*  victory_status - Could be dropped unless you want to differentiate resignation, checkmate, etc.
"""

# Drop unnecessary columns

columns_to_drop = ['id', 'increment_code', 'opening_eco', 'moves', 'created_at', 'last_move_at']
df.drop(columns=columns_to_drop, inplace=True)
#column_to_drop = ['victory_status']
#df.drop(columns=column_to_drop, inplace=True)


# Show remaining columns
print(df.columns)

"""## ðŸ“Š Step 5: Most Successful Openings"""

# Remove draws for clarity.
df_wins = df[df['winner'] != 'draw']

# Group by opening and winner
openings = df_wins.groupby(['opening_name', 'winner']).size().unstack(fill_value=0)
openings['total'] = openings.sum(axis=1)
openings['white_win_rate'] = openings['white'] / openings['total']
openings['black_win_rate'] = openings['black'] / openings['total']

# Top 10 white openings
top_white = openings[openings['total'] > 50].sort_values(by='white_win_rate', ascending=False).head(10)

# Plot
top_white['white_win_rate'].plot(kind='barh', color='skyblue')
plt.xlabel("White Win Rate")
plt.title("Top 10 Openings by White Win Rate")
plt.gca().invert_yaxis()
plt.show()

df_wins = df[df['winner'] != 'draw']

openings = df_wins.groupby(['opening_name', 'winner']).size().unstack(fill_value=0)
openings['total'] = openings.sum(axis=1)
openings['white_win_rate'] = openings['white'] / openings['total']
openings['black_win_rate'] = openings['black'] / openings['total']


# Top 10 black openings

top_black = openings[openings['total'] > 50].sort_values(by='black_win_rate', ascending=False).head(10)

# Plot
top_black['black_win_rate'].plot(kind='barh', color='indigo')
plt.xlabel("Black Win Rate")
plt.title("Top 10 Openings by Black Win Rate")
plt.gca().invert_yaxis()
plt.show()

"""**Results of an Analysis**

*   For White, classical, open positions based on rapid development and control of the center are more successful..
*   Successful openings for Black are often based on a more strategic or counterattack-oriented style.
*  Timely preparation and choosing the right strategy plays an important role in winning a chess game.

## ðŸŽ¯ Stage 6: Player Performance by Rating
"""

# Was white higher rated?
df['white_higher'] = df['white_rating'] > df['black_rating']

# Did higher-rated player win?
df['higher_won'] = ((df['white_higher']) & (df['winner'] == 'white')) | \
                   ((~df['white_higher']) & (df['winner'] == 'black'))

# Countplot
sns.countplot(x='higher_won', data=df)
plt.xticks([0, 1], ['No', 'Yes'])
plt.title("Did Higher-Rated Player Win?")
plt.show()

"""**Analysis Results**

*   Higher-rated players win more often.
*   However, lower-rated players also win often â€“ the (no) column is also quite high, which shows that winning is not only dependent on rating, and lower-rated players can win too.
*  Rating is an important factor, but not the decisive one.

"""

# Rating difference histogram
df['rating_diff'] = df['white_rating'] - df['black_rating']
sns.histplot(data=df, x='rating_diff', hue='winner', multiple='stack')
plt.title("Game Result by Rating Difference (White - Black)")
plt.xlabel("Rating Difference")
plt.show()

"""**Analysis Results**

*   The most games are close to zero. This means that players of equal level often clash with each other.
*   The green (draw) ones are mostly close to zero, which means that games between players of equal rating often end in a draw.
*  As the difference increases, the results become clearer. When the rating difference is very large (+-1000 or more), the chances of the lower-rated player to win decrease sharply.

## âœ… Summary
- We identified profitable chess openings
- We found that high-rated players win more often
- We observed how starting colors and rating differences affect outcomes.
"""